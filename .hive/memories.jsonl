{"id":"mem-004bdd2d5ac7891c","information":"App.tsx integration pattern for annotation image data: Import getAnnotationImageData and clearAnnotations from useDrawingContext. Before calling agenticService.edit(), get annotation data with const annotationImageData = getAnnotationImageData(). Pass it as 4th parameter (works for both inpainting and text-only modes). Call clearAnnotations() in three places: (1) when dialog opens via useEffect with isOpen dependency, (2) after successful generation, (3) after failed generation or cancel.","created_at":"2025-12-29T13:21:20.262Z","tags":"app-integration,agentic-service,annotation-cleanup,useEffect"}
{"id":"mem-0f4909a0b630df16","information":"DrawingContext pattern for adding new state: \n1. Add types/constants to src/types/drawing.ts using the const object + typeof pattern\n2. Add state fields to DrawingState interface in drawing.ts\n3. Add action types to DrawingActionType enum in DrawingContext.tsx\n4. Add action definitions to DrawingAction union type\n5. Update initialState with default values for new fields\n6. Add reducer cases to handle the new actions\n7. Add method signatures to DrawingContextType interface\n8. Implement methods in DrawingProvider.tsx using useCallback\n9. Add methods to the value object in DrawingProvider\n\nThis pattern keeps state management consistent with the existing codebase.","created_at":"2025-12-29T13:09:00.799Z","tags":"react-context,state-management,drawing-context,patterns"}
{"id":"mem-10ef1d692f152753","information":"When creating components that need to capture ImageData for AI processing, use raw HTML canvas instead of React Konva. React Konva is great for interactive shapes, but raw canvas provides direct access to ctx.getImageData() which is required for sending pixel data to AI APIs. The pattern is: canvas ref + useEffect for rendering + mouse handlers on canvas element.","created_at":"2025-12-29T13:14:03.597Z","tags":"canvas,imagedata,ai-integration,react-patterns"}
{"id":"mem-187a7b566afe2b04","information":"Integrated annotation mode into GenerativeFillDialog. Added \"Add Annotations\" button that appears when mask exists in inpainting mode. When clicked, starts annotation mode which shows AnnotationToolbar and AnnotationLayer overlay. The AnnotationLayer is positioned over the mask preview using a ref to measure dimensions. When user clicks \"Done\" in AnnotationToolbar, endAnnotationMode() hides the toolbar but keeps annotations visible. When \"Generate\" is clicked, getAnnotationImageData() retrieves the ImageData and passes it to agenticService.edit() as the 4th parameter. After generation completes or is cancelled, clearAnnotations() is called to reset state.","created_at":"2025-12-29T13:21:08.467Z","tags":"annotation-integration,generative-fill-dialog,drawing-context,annotation-layer"}
{"id":"mem-2c8237d69f390697","information":"AnnotationLayer component uses raw HTML canvas (not React Konva) to support ImageData capture. The component handles mouse/touch events directly on canvas element and uses requestAnimationFrame for smooth freehand drawing. All 5 annotation tools (freehand, text, arrow, circle, rectangle) are implemented with bright red (#FF0000) color and 3px line width. On completion, it calls dispatch with ADD_ANNOTATION and SET_ANNOTATION_LAYER actions. Text tool shows an HTML input overlay positioned at click location.","created_at":"2025-12-29T13:13:57.851Z","tags":"annotation-layer,canvas,drawing,generative-fill,html-canvas"}
{"id":"mem-863f881e83191ee5","information":"Fixed debug dialog appearing multiple times during agentic iteration. The AgenticPainterService iterates up to MAX_ITERATIONS=3 times calling inpaintWithGemini. The showDebugDialog() was being called inside inpaintWithGemini on every iteration.\n\nSolution: Moved showDebugDialog() call from generativeApi.ts (inpaintWithGemini) to agenticService.ts (after iteration loop completes). Made showDebugDialog() public so the agentic service can call it.\n\nKey insight: When an underlying service is called multiple times in a loop, UI feedback (dialogs, notifications) should be controlled by the coordinator (the loop owner), not the underlying service. The underlying service shouldn't know about iteration context.\n\nPattern: Separate concerns - service does work, coordinator controls UI feedback based on iteration/completion state.","created_at":"2025-12-29T10:35:08.953Z","tags":"agentic-service,ui-feedback,iteration-loop,separation-of-concerns"}
{"id":"mem-b6b3d0fa81d3cf62","information":"When updating agenticService.edit() to accept annotationImage parameter, the annotations are composited onto the source image before sending to Gemini API. This is done by creating a temp canvas, drawing source first, then drawing annotations on top. The composited image is then used for all API calls (planning, generation, self-check) so Gemini sees the annotations as visual instructions. The system prompt is updated to tell Gemini that red annotations are instructions and should NOT be included in the output.","created_at":"2025-12-29T13:15:05.498Z","tags":"agenticService,annotations,image-composition,gemini-api"}
{"id":"mem-c40765cd9ac2f35f","information":"GenerativeFillDialog positioning strategy for AnnotationLayer: Used a ref (previewContainerRef) on the preview container div, then useEffect to measure its dimensions when annotation mode starts. This ensures AnnotationLayer canvas matches the preview area size. The AnnotationLayer is rendered as a sibling to the mask image with position: absolute to overlay it.","created_at":"2025-12-29T13:21:13.747Z","tags":"react-patterns,canvas-positioning,refs,annotation-layer"}
{"id":"mem-c59d3686b5f68e9a","information":"AnnotationToolbar component created for AI annotation mode. Uses floating overlay pattern with semi-transparent background (rgba(255, 255, 255, 0.45)) and backdrop blur (12px), matching AIProgressPanel styling. Component provides tool buttons for FREEHAND, TEXT, ARROW, CIRCLE, RECTANGLE annotations, plus Clear All and Done buttons. All annotations drawn in bright red (#FF0000). Uses useDrawingContext() hook to access setAnnotationTool, clearAnnotations, endAnnotationMode methods. Active tool highlighted with red border and background tint.","created_at":"2025-12-29T13:12:56.176Z","tags":"annotation-toolbar,floating-ui,generative-fill,drawing-context"}
{"id":"mem-d8e5ce9680bce572","information":"When modifying a TypeScript method signature to add optional parameters, all call sites must be updated to pass undefined for the new optional parameter if not using it. This is necessary for TypeScript compilation. For agenticService.edit(), added annotationImage as 4th parameter before onProgress callback, requiring callers to pass undefined when not providing annotations.","created_at":"2025-12-29T13:15:11.616Z","tags":"typescript,method-signature,backward-compatibility"}